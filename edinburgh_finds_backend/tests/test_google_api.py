import os
import json
from dotenv import load_dotenv
from sqlmodel import SQLModel
from google import genai
from google.genai import types
from models.models import Listing, Venue

# ====================================================================
# STEP 1: DEFINE THE TARGET SCHEMA (FLAT INHERITANCE)
# ====================================================================

class FullVenueData(SQLModel):
    @classmethod
    def merge_listing_and_venue(cls, listing: Listing, venue: Venue) -> "FullVenueData":
        data = {
            **listing.model_dump(exclude={'venue'}),
            **venue.model_dump(exclude={'listings'})
        }
        return cls(**data)

def get_extraction_schema(listing_class, entity_class) -> dict:
    """
    Combine schemas from Listing and entity-specific class for LLM extraction.
    Automatically respects exclude flags set in Field definitions.

    Args:
        listing_class: Listing model class (general attributes)
        entity_class: Entity-specific model class (e.g., Venue)
    
    Returns:
        Combined JSON schema suitable for LLM structured output
    """
    # mode='serialization' respects exclude=True flags
    listing_schema = listing_class.model_json_schema(mode='serialization')
    entity_schema = entity_class.model_json_schema(mode='serialization')
    
    # Clean up schemas - remove additionalProperties which Gemini doesn't support
    def clean_schema(schema):
        """Recursively remove Gemini-unsupported additionalProperties (dicts) and additionalItems (lists) from schema"""
        if isinstance(schema, dict):
            schema.pop('additionalProperties', None)
            schema.pop('additionalItems', None)  # ‚Üê Add this
            for value in schema.values():
                clean_schema(value)
        elif isinstance(schema, list):
            for item in schema:
                clean_schema(item)
        
    clean_schema(listing_schema)
    clean_schema(entity_schema)

    # Combine properties
    combined_schema = {
        "type": "object",
        "properties": {
            **listing_schema.get('properties', {}),
            **entity_schema.get('properties', {})
        },
        "title": f"{listing_class.__name__}{entity_class.__name__}Combined"
    }
    
    return combined_schema

def generate():
    
    combined_schema = get_extraction_schema(Listing, Venue)
    
    load_dotenv(override=True)

    client = genai.Client(
        api_key=os.environ.get("GEMINI_API_KEY"),
    )

    model = "gemini-2.5-flash-lite" 
    
    prompt_text = (
        "Thoroughly research the 'Craigmillar Park Tennis & Padel Club' in Edinburgh. "
        "Your task is to extract ALL available operational, contact, and facility data. "
        "Populate every field in the provided JSON schema using the grounding tools."
    )
    
    contents = [
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text=prompt_text),
            ],
        ),
    ]

    # --- CONFIGURE THE REQUEST ---
    generate_content_config = types.GenerateContentConfig(
        response_mime_type="application/json",
        response_schema=combined_schema,
        temperature=0.1, 
        tools=[
            types.Tool(google_search=types.GoogleSearch()),
            types.Tool(google_maps=types.GoogleMaps()),
        ],
    )

    print(f"--- Running {model} for RAW JSON Output ---")
    
    try:
        # Use the non-streaming method to get the full response object
        response = client.models.generate_content(
            model=model,
            contents=contents,
            config=generate_content_config,
        )
        
        # *** MODIFICATION: Print the raw JSON string directly from the response object ***
        print("\n" + "="*50)
        print("RAW MODEL RESPONSE (Full JSON Schema Output):")
        print("="*50)
        
        # Use json.dumps to pretty-print the JSON string for better readability
        # The response.text is the JSON string generated by the model
        parsed_json = json.loads(response.text)
        print(json.dumps(parsed_json, indent=4)) 
        
    except Exception as e:
        print(f"\n\nAn API Error occurred. Full error: {e}")

    print("\n--- End of Execution ---")

if __name__ == "__main__":
    generate()